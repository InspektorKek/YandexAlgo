//
//  Homework1.cpp
//  YandexAlgo
//
//  Created by Mikhail Borisov on 6.12.23.
//

/*
MARK: - Test link: https://contest.yandex.ru/contest/23815/run-report/102216817/
 
-- ЗАДАЧА --
 Разработать алгоритм для поиска элемента в сломанном массиве, где исходный отсортированный массив был сдвинут, сохраняя уникальность элементов.
 ВАЖНО!!! Time complexity O(log n).
 
-- ПРИНЦИП РАБОТЫ --
 Алгоритм - это бинарный поиск. 
 Основная идея - разделение массива на две части, одна из которых всегда отсортирована, что позволяет эффективно локализовать зону поиска.
 При каждом шаге алгоритм определяет, находится ли искомый элемент в отсортированной или неотсортированной части, сужая область поиска и
 используя свойства отсортированности для ускорения процесса.
 
-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
 Корректность алгоритма обусловлена правильным применением принципов бинарного поиска к структуре сломанного массива. Разделение массива на 
 отсортированную и неотсортированную части при каждом шаге гарантирует, что поиск всегда направлен и эффективен.
 
-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
 Временная сложность = O(log n), поскольку он систематически делит массив пополам при каждом шаге.

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
 Пространственная сложность алгоритма ограничена O(1), так как для выполнения операций используются лишь ограниченное количество переменных, 
 а сам массив не модифицируется и не копируется.
*/

#include <vector>
#include <cassert>

int broken_search(const std::vector<int>& vec, int k) {
    int left = 0;
    int right = vec.size() - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;

        // Проверяем, нашли ли мы элемент
        if (vec[mid] == k) {
            return mid;
        }

        // Определяем, какая часть массива отсортирована
        if (vec[left] <= vec[mid]) {
            // Левая часть отсортирована
            if (k >= vec[left] && k < vec[mid]) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        } else {
            // Правая часть отсортирована
            if (k > vec[mid] && k <= vec[right]) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
    }

    // Если элемент не найден
    return -1;
}

void test() {
    std::vector<int> arr = {19, 21, 100, 101, 1, 4, 5, 7, 12};
    assert(6 == broken_search(arr, 5));
}
