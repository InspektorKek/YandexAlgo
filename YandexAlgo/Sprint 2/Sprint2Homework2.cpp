////
////  Sprint2Homework2.cpp
////  YandexAlgo
////
////  Created by Mikhail Borisov on 24.11.23..
////
//
///*
//MARK: - Test link: https://contest.yandex.ru/contest/22781/run-report/99034442/
//
//-- ЗАДАЧА --
//Реализовать алгоритм вычисления результата арифметического выражения из строки, организованной по обратной польской нотации (RPN).
//
//-- ПРИНЦИП РАБОТЫ --
//Принцип работы:
// 1. Преобразовать входную строку в массив токенов
// 2. Создат стэк
// 3. Последовательно проходить по массиву
//    - если это число, то добавляем его в стэк
//    - если это оператор, то достаем и стэка два верхнич числа. Ипользуюя оператор получаем результат арифметической операции и добавляем его в стэк
// 4. Результатом становится полесдний элемент в стэке
//
//-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
// Алгоритм использует стек (LIFO - Last In, First Out), что обеспечивает корректность вычислений:
//
// 1. Порядок Операндов: Операнды помещаются в стек, а операции применяются к последним добавленным операндам, что соответствует необходимому порядку для выполнения операций.
// 2. Порядок Операций: Операции выполняются немедленно после встречи оператора, что гарантирует соблюдение порядка, заданного в выражении RPN.
// 3. Ассоциативность и Приоритет: Не требуется специальная обработка приоритетов операторов, так как порядок операций уже задан в выражении RPN.
// 4. Результат: В конце в стеке остается единственное значение, являющееся результатом вычисления всего выражения, если количество операций было корректным.
// Эти факторы обеспечивают корректность алгоритма для вычисления выражений в формате RPN.
//
//-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
// Временная сложность алгоритма зависит от количества элементов в выражении и равна O(n), где n — общее количество элементов.
// Основные операции:
// 1. Перебор элементов: Каждый элемент обрабатывается один раз. Для каждого элемента выполняются операции с O(1).
// 2. Операции со стеком: Операции добавления в стек и удаления из стека выполняются за O(1). Общее количество операций со стеком пропорционально количеству элементов.
// 
//Таким образом, общая временная сложность алгоритма линейно зависит от размера входных данных и составляет O(n).
//
//-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
// Пространственная сложность алгоритма вычисления выражений в RPN равно O(n), где n — общее количество операндов и операторов в выражении.
// 
//*/
//
//#include <iostream>
//#include <stack>
//#include <string>
//#include <sstream>
//#include <stdexcept>
//
//int calculate(int a, int b, char operand) {
//    switch (operand) {
//        case '+': return a + b;
//        case '-': return a - b;
//        case '*': return a * b;
//        case '/':
//            // Handling division rounding towards negative infinity
//            return (a / b) - ((a % b) && ((a < 0) ^ (b < 0)));
//        default: throw std::runtime_error("Unknown operation");
//    }
//}
//
//void solution(std::string line) {
//    std::stack<int> stack;
//    std::istringstream iss(line);
//    std::string token;
//
//    while (iss >> token) {
//        // Operand
//        if (isdigit(token[0]) || (token[0] == '-' && token.size() > 1)) {
//            stack.push(std::stoi(token));
//        } else { // Operator
//            int b = stack.top(); stack.pop();
//            int a = stack.top(); stack.pop();
//            stack.push(calculate(a, b, token[0]));
//        }
//    }
//
//    std::cout << stack.top() << "\n";
//}
//
//int main() {
//    std::string line;
//    while (std::getline(std::cin, line)) {
//        solution(line);
//    }
//    return 0;
//}
